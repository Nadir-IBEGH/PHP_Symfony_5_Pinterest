----------------------------------------------- Video 01-------------------------------------------
cours :  Pinterrest

lister tout les pins
affichier le détail d'un pin
modifier un pin
supprimer un pin

modifier nos informations de profil
modifier notre mot de passe
réinitialiser notre mot de passe
se connecter 
vérifier notre adresse email


https://www.youtube.com/watch?v=_WS5ZNl043s&t=26s


Etapes : 

1. creation du projet :

symfony new panterest --full

symfony open:local   --> pour ouvrir le projet 

pour l'erreur no driver found alors ajouter la ligne suivante dans le fichier .env

DATABASE_URL="mysql://root:@127.0.0.1:3306/symshop?serverVersion=mariadb-10.4.11"


php bin/console doctrine:database:create      --- > pour créer la base de données une fois que on a repris le projet


créer l'entité Pin avec title et description

créer la base de données :

php bin/console doctrine:database:create

php bin/console doctrine:database:drop --force --> pour supprimer la base de données

php bin/console doctrine:migration:status --show-versions

 
installer le bundle PsyshBundle  pour l'affichage des pins 

https://www.youtube.com/watch?v=_WS5ZNl043s&t=26s

composer require --dev theofidry/psysh-bundle

pour séparer le singulier du pluriel  on crée une extension de twig : pluralize

make:twig-extension  => Creates a new Twig extension class


pour créer une extension twig lors on crée un class extension comme ceci :

php bin/console make:twig-extension puis on donne le nom de la classe (AppExtension)

     * @Route("/pins/{id<[0-9]+>}", name="show_pin")   ==      * @Route("/pins/{id<\d+>}", name="show_pin")

php bin/console debug:router pour voir les routes de notre application


pour personnaliser mes page d'érreur (404 par exemple) alors on va taper tout somplement sur google customize error page symfony

https://symfony.com/doc/current/controller/error_pages.html#overriding-the-default-error-templates

ajouter les champs cretedAt and updatedAt

pour cela ajouter dans l'entité pin : HasLifecycleCallbacks

https://symfony.com/doc/current/doctrine/events.html


 * @ORM\HasLifecycleCallbacks  => vaut dire qu'on écouter les différents évenements du cycle de vie de l'entité

 l'annotation se rajoute avant de nom de l'entité 

prePersist/postPersist, preUpdate/postUpdate .......


DateTimeImmutable  -> donne un objet date qu'on ne peut pas modifier

Pour chanegr le fusion horaire alors on ajoute dans le projet un fichier php.ini et on mets le fusion horraire qu'on souhaite dedans
stoper le server puis le relancer pour que les modifs du fichier php.ini soit prise en compte


php bin/console doctrine:migrations:migrate prev   -- revenir a la version precedente de la migration (annulez la dernière migration)

first - Migrate down to before the first version.
prev - Migrate down to before the previous version.
next - Migrate up to the next version.
latest - Migrate up to the latest version.
note : on peut par default a un champs une valeur avec une annotation
par exemple pour les champs date existant déja dans la base de données

    /**
     * @ORM\Column(type="datetime", options={"default" : "CURRENT_TIMESTAMP"})
     */
    private $createdAt;

    on donne au champs existant createdAt dans la base de données une valeur qui est la date actuelle

----------------------------------------------- Video 02-------------------------------------------


tous ce qu'on peut trouver dans debug:autowiring on peut l'injecter (injection de dépendance)

   Pour envoyer un formulaire sans validation     
   <input type="submit" value="Update Pin" formnovalidate/>

https://openclassrooms.com/forum/sujet/symfony-4-compteur-de-visites-uniques


verbe http i; y en a plusieurs (pas uniquement 4)

https://developer.mozilla.org/fr/docs/Web/HTTP/Methods

le formulaire delete pin n'ai pas protéger avec un token CSRF donc il faut le proteger 

voir le cours Attaques CSRF ou XSRF:
https://www.youtube.com/watch?v=4xQmrsOh1Oc

cours de git https://www.youtube.com/watch?v=zNxGgI6O5NE&list=PLlxQJeQRaKDRBd_FazeI7gLq5wyrt7f7J
 
$request->query     --> get
$request->request   --> post

pour voir les données soumises alors on a 

dd($request->request->all());  dans le controller

dd($request->request->get('nom_du_champs_formulaire'));  dans le controller

----------------------------------------------------------Video 03-----------------------------------------------

Erreur après composer update (Correction)

composer show pour voir tout les packages installer 

composer show doctrine/doctrine-migrations-bundle    pour voir le bundle doctrine 

php bin/console doctrine:database:create   --créer la base de données

correction erreur migration 

composer unpack orm-pack   --> permet de décomposer orm-pack en plusieurs bundle/librairies dans le fichier composer.json 
 
  "symfony/orm-pack": "*",

   ca donne      

        "doctrine/doctrine-bundle": "^2.3"
        "doctrine/doctrine-migrations-bundle": "^3.1",
        "doctrine/orm": "^2.8",


il ya une répétition du formulaire edit/create donc en crée un entre fichier twig qui va remplacer les deux 


<input type="submit" value="{{ submitButtonText }}" formnovalidate/>

est equivalent a 

<input type="submit" value="{{ submitButtonText|default('Create Pin') }}" formnovalidate/>

est équivalent à 

<input type="submit" value="{{ submitButtonText ?? 'Create Pin' }}" formnovalidate/>


message d'erreur : pour voir a quoi vont correpondre nos messages en prod en fait ceci :

dans le fichier .env en place


APP_ENV=prod

puis

https://127.0.0.1:8000/error/404

ou 

https://127.0.0.1:8000/error/500   ainsi de suite

on peut biensur costumiser les pages d'érreurs

si un text est très long en peut le trunquer ( filtre u )


pour gérer l'affichage de la description en fait ceci : 

<p>{{  pin.description |u.truncate(10, '...', false) }} </p>
composer require twig/string-extra

https://twig.symfony.com/doc/3.x/filters/u.html  --> doc

pour affichier depuis quand l'élément a été créé alors en ajoute le bundle :

https://github.com/KnpLabs/KnpTimeBundle

composer require knplabs/knp-time-bundle

----------------------------------------------------------Video 04---------------------------------------------------------

ajouter les messages flash

gérer la validation du formulaire

pour voir la liste de validation possible alors va dans vendor/symfony/validator/Constraints

ajouter bootstraap pour styliser notre application

puis ajouter un theme symfony 

https://symfony.com/doc/current/form/form_themes.html

ajouter un layout dans twig.yaml : 

form_themes: [ 'bootstrap_4_layout.html.twig']

error dans edit/formulaire : 

Expected argument of type "string", "null" given at property path "title".

dans setTitle(string $title) en change en setTitle(?string $title) pour accepter les valaurs null


un bundle créé par le développeur 

https://www.youtube.com/watch?v=sxLceVKcWoc&t=0s

ajouter un header

regarder absolument les astuces twig

https://www.youtube.com/watch?v=E4nUjUsxJNc&list=PLlxQJeQRaKDS_Kd9ZCLy4ViK3-5y5AnGC
 


meetre du style : changer la police 

montserrat font 


https://fonts.google.com/specimen/Montserrat?selection.family=Montserrat#standard-styles

on choisit bold 700

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"
              integrity="sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l"
              crossorigin="anonymous">
rajouter aussi :
font-family: 'Montserrat', sans-serif;

    html, body {
                font-family: 'Montserrat', sans-serif;
            }


webpack (pour mieux organiser les fichiers js css et png

en symfony en a webpack encore  

installer webpack (bundle webpack-encore-bundle)

en faisant : composer require encore (en utilise une alias mais il y en a beaucoup) 


https://flex.symfony.com/

nodes_modules et a peu près l'equivalent en javascript du vendor en symfony

package.json dans le monde javascript est equivalent a composer.json en symfony

ou peut utiliser yarn ou npm c'est pareil

il suffit de taper yarn pour que les depandences s'installe

pour executer les commandes de package.json on procède comme ceci :

-> npm run nom_de_la_commande ( dev, watch, build, ...)

-> yarn  nom_de_la_commande   ( dev, watch, build, ...)



-----> lancer yarn dev  --> va générer des fichiers dans public/build

pour utiliser Saas il faut activer dans webpack.config.js .enbleSassLoader() // en enlevant les commantaires

il faut a chaque fois qu'on modifie webpack.config.json on doit relancer yarn watch

----> apprendre saas

webpack encore bootrstraap

yarn add bootstrap --dev


puis yarn watch

pour ajouter le javascript au boorstraap en install jquery 


yarn add jquery popper.js --dev

https://symfonycasts.com/screencast/webpack-encore


si on est en production on utilise : yarn build pour générer les fichiers a utiliser en prod  


-------------------------------------------------------------video 5--------------------------------------------------------

upload d'images


Ajouter un champs dans le pin imageName dans le Pin




regarder la doc symfony, elle est bien faites


1. ajouter le champs dans l'entité Pin

remarque : on ne sauvegarde pas l'image dansla base de données mais juste le lien/nom de l'image

on stock les images sur le serveur 

lors de la creation du pin l'image n'ai pas obligatoire : donc le préciser lors de l'ajout de champs imageName qu'il peut etre null dans la base de données


Une solution : en utilise le bundle : vich uploader

https://github.com/dustin10/VichUploaderBundle
 

Pour installer le bundle :

composer require vich/uploader-bundle


taper yes pour confirmer l'execution de la recette, elle demande une conifmration car elle n'ai pas officiel

regarder la documentation pour voir comment utiliser le bundle

suivi la documentation pour faire les configuration nécessaires

une fois qu'on a fini l'étape 2 on fait ceci :

php bin/console cache:clear


suivi ....

une erreur :

LiipImagineBundle must be installed and configured for using "imagine_pattern" option.

enlever dans le code :                 'imagine_pattern' => '...',


valider la taille des images : imagesize symfony dans google  

https://symfony.com/doc/current/reference/constraints/Image.html

pour rendre l'image obligatoire dans le formulaire il suffit de rajouter Assert/NotNull or NotBlanc

NotBlanc contient dedans NotNull


$options['method']  dans formBuilder (PUT/POST)

on peut utiliser aussi :  $options['data']     -->video 5 minutes 42 



Thumbnail Images  pour afficher les images en petit forme :
pour cela on utilise le bundle : liip imagine 

https://github.com/liip/LiipImagineBundle

$ composer require liip/imagine-bundle

par defaut en utilise "gd" mais c'est intéressant de voir comment utiliser "gmagick" (regarder sur internet comment l'installer)


important : tu peux rechercher les réponses au bugs dans les issues 


en production pour le chargement rapide d'images en utilise symfony Messenger (regarder la video sur youtube) 

vider le cache en vas de problème 


rechercher sur internet liip imagine filter_sets : (pour continuer la configuration)

https://symfony.com/doc/current/bundles/LiipImagineBundle/filters.html

https://symfony.com/doc/current/bundles/LiipImagineBundle/filters/sizing.html#thumbnails


Afficher le nom du fichier dans le input : avec jquery


une fois que  le js est ajouté alors lancer yarn dev ou/  yarn watch   --> pour webpack

yarn build :  pour la production (évite les problème du cache)



ajouter une margin-top dans le sass : 

.vich-image .form-check {
  @extend .mt-3    ----------> en hérite les classes de bootstraap
} 


Pour afficher l'image : vitch uploader

https://github.com/dustin10/VichUploaderBundle
https://github.com/dustin10/VichUploaderBundle/blob/master/docs/generating_urls.md



ajouter un filtre pour que l'image soit petite dans twig

liip imagine bundle 

a chaque fois quand modifie le js et css en fait yarn build

& dans scss : vaut dire ou est ce qu'on se trouve.

copier le dossier images de build vers asset puis ajouter dans  webpack.config.js :

  .copyFiles({
        from: './assets/images',
        pattern: /\.(png|jpg|jpeg)$/,
        // to path is relative to the build directory
        to: 'images/[path][name].[ext]'
    })

 
avec ce code lorsque qu'on fait yarn build les images seront copier depuis asset vers le build

------------------------------------------video 6 ---------------------------------------------

composer recipes pour voir s'il y a d'éventuel mis a jour pour les bundle

Pour mettre a jour un bundle on procede de cette facon : 

1. composer recipes : afficher tout les bundle donc les bundle qui ont besoin d'une mise à jour

2. composer recipes + nom_bundle_a_mettre_jour   ---> ca donne la commande a executer pour mettre a jour le bundle


commit : mettre a jour quelques recettes

pour revenir a la dernière version d'un fichier après un git status on fait :
git restore _nom_du_fichier

créer en entité user 

User :
    - firstName
    - lastName
    - email
    - password
    - createdAt  (date creation)
    - updatedAt  (date dernière modification de ses infos)

Une relation entre pin et user

    - un utiliateur peut créer un ou plusieurs pins


on peut bien créer l'entité user comme nous l'avons fait avec pin cad: 
php bin/console make:entity puis on donne le nom de d'entité (User) 
mais pour cela on a une commande qui ne s'implifie les chose : c'est la commande 
  
make:user   -->pour la voir il suffit de taper php bin/console make:entity (permet de voir la liste de toute les commandes disponibles)


supprimer tout les fichiers .gitignore dans le src (dans les sous repertoire)


editer l'entité user pour ajouter de nouveaux champs : 

php bin/console make:entity User 

firstName
lastName


avant de faire make:migration rajouter dans l'entité User :

 * @ORM\Table(name="users")

 pour que le non de la table soit users au lieu de user



utiliser psysh :  pour créer des utilisateur

1. php bin/console psysh

2. use App\Entity\User;
3. $user1 = new User;
4. dump($user1)  ->  en voit l'entité user avec tous les champs null
5. $user1->setFisrtName('nadir');
6. dump($user1)  -> on voit que le prenom a été modifié

on ne va pas ecrire le code, il doit etre haché avec : security:encode-password (commande existante dans php bin/console 

pour encoder un mot de passe avec psysh :

php bin/console security:encode-password  

on ne demande de taper le mot de passe qui ne sera pas visible bien sur : je tape *nadir-

ca va me générer un mot ded passe hacher :

je copie le motde passe :

au lieu de faire 

$user1->setPassword('*nadir-');  je fais a la place  $user1->setPassword('le mot de passe hacher générer par la commande php bin/console security:encode-password '); 


7. $user1->setPassword('$argon2id$v=19$m=65536,t=4,p=1$c1BrWGl6QW80NkpkOVBUVA$6J2hkuHduEIyfvI0px6NKho5suy5Zta9jZqgG2HGeq8');
8. $em = $container->get('doctrine')->getManager();
9. $em -> persist();
10. $em -> flush();

pour le même mot de passe les hash seront différents : grace a une fonction de hachage 

pour hacher un mot de passe il est recommandé de ne pas utiliser md5 car il ya des algorithme beaucoup plus sécurisé


remarques : 

hash('sha256', 'secret') -> produit un hachage de 64 caractère 

alors que md5('secret')-> produit un hachage de 32 caractère

hash('sha512', 'secret') -> produit un hachage de 128 caractère 

avec md5 : hacher le même nom donne toujours le même résultat

note securite : la fonction de hachage qui donne la meme cle pour le même mot c'est dangereux car si on a un mot de passe d'un utilisateur on aura l'autre mot de passe 
des utilisateurs qui ont une clé qui se resemble.

on peut utiliser dans security.yaml plusieurs encoder possible 

note programmation :  une méthode qui a un corp vide c'est une méthode qui retourne null

public function nadir () {}

est equivalent a 

public function nadir () { return null; }


ajouter une relation entre user et pin pour que chaque pin soit associer a un utilisateur 

chaque utilisateur va avoir entre 0 et n pin 
chaque pin appartient a un et un seule user 
donc dans table pin on va avoir une clé étranger du l'id du user (dans le modele relationnel de données)

pin  ---------{ManyToOne  }---------------user

comment l'ajouter : avec dosctrine :

on va ajouter user dans l'entité pin comme ceci :

1. php bin/console make:entity pin
2.  ?
3. ManyToOne
4. fait attention au question posé yes/no -> on ne doit pas avoir de pin orphelin donc quand on supprime un user alors on supprime tout les pins associés à cette user.

Quand on fait la migration on recontre problème de clè étranger (qui ne doit pas etre null) alors il y a plusieurs manière de résoudre le problème :
1. si la base de données est déja en production :

en va changer : 

        $this->addSql('ALTER TABLE pins ADD user_id INT NOT NULL');

en 

        $this->addSql('ALTER TABLE pins ADD user_id');  puis on ajoute des valeurs au différents pins

2. si la base de donnée est en dev comme dans notre cas alors :

   1. supprimer ma base de données : php bin/console: doctrine:databse:drop --force
   2. créer à nouveau notre base de données : php bin/console doctrine:database:create
   3. appliquer les migrations : php bin/console doctrine:migrations:migrate


On utilise des fixtures pour générer de fausses données (faux pins et faux users)

  
1 . php bin/console psysh
2. use 	App\Entity\{User, Pin};
3. $u1 = new User;
4. $u1->setFistName('u 1 prenom');
5. $u1->setLastName('u 1 nom');
générer un mot de passe avec security:encode-password 
donner secret comme mot de passe :
php bin/console security-encode-password 
puis taper secret --> un mot de passe hacher sera créer alors 

1$TlZGRHRhaTR4Lk9ONmR2bQ$jFYInrVqJWzAPbXSUWByTeybOavP+K6kYDerAt7Tf+4

6.$u1->setPasswrd('1$TlZGRHRhaTR4Lk9ONmR2bQ$jFYInrVqJWzAPbXSUWByTeybOavP+K6kYDerAt7Tf+4');

7. dump($u1); --> pour la vérification 
8. $u1->setEmail('u1@gmail.com');
9. $em = $container -> get('doctrine')->getMnager();
10. $em ->persist($u1);
11. $em ->flush();

---> céer le pin :

$p1 = new Pin;


 
Pour ce message d'érreur :

Doctrine\ORM\ORMException with message 'The EntityManager is closed.'

En fait ceci :

>>> $em = $container->get('doctrine')->resetManager();


si l'entité manager est fermé on peut faire ceci :

php bin/console psysh   (redémarre à nouveau)

au lieu de faire {{ pin.user.firstName }} {{ pin.user.lastName }} on pourra faire : {{ pin.fullName }}

pour cela ajouter une méthode dans l'entité User : 


Video a regarder : Authentification et Autorisation avec Symfony 5
https://www.youtube.com/watch?v=wCvGbv6E0AI


message d'érreur pour la page 403 : "Customize 403 page"


----------------------------------------------Video 7---------------------------------------------

text-break : pour éviter que le text sort du div


Sécurité vaut dire deux choses : 
  - Authentification (qui vous etes) gérer par les firewalls
  - Autorisation (droits nécessaires)

dans symfony la sécurité est gérer par le bundle SecurityBundle

Pour acceder à l'utilisateur dans twig: {{ app.user }}

pour générer un controller d'authentification (LoginController) on utilise une commande make:auth

1. php bin/console make:auth
2. What style of authentication do you want? [Empty authenticator]:
  [0] Empty authenticator
  [1] Login form authenticator
 
>Reponse : 1
3. The class name of the authenticator to create (e.g. AppCustomAuthenticator):

Reponse : LoginFormAuthentificator 

4.  Choose a name for the controller class (e.g. SecurityController) [SecurityController]:
 >  Entrer
5. Do you want to generate a '/logout' URL? (yes/no) [yes]:
 > Enter


class LoginFormAuthentificator :


Toute les requete appelle la méthode supports() (il suffit de mettre un die dd('stop');

$request->attributes->get('_route')   dans support permet d'acceder a la route courante 


pour recupérer les données de la requete on fait :

 $request->request->get('email')  --> GET
 $request->query->get('email')   --> POST


php bin/console debug:autowiring csrf  --> pour voir s'ilya des service csrf qu'on peut injecter (il y en a biensur)

On peut récuperer le UserRepository comme ceci :

$user = $this->entityManager->getRepository(User::class)->findOneBy(['email' => $credentials['email']]);

Comme on peut injecter le service dans le constructeur comme ceci :

UserRepository $userRepo puis

$user = $this->userRepo->findOneBy(['email' => $credentials['email']]);



si en veux acceder a la session on peut utiliser le service :

php bin/console debug:autowiring session    -> SessionInterface

une fois que connecter bloquer l'accès a la page de connexion

----------------------------------------------------------------- * Video 8 * -----------------------------------------------------------

Autorisation : on vérifie si on a les droits nécessaires pour éffectuer différentes actions (par exemple editer un pin : on doit etre de propriètaire)

alias et racourcis terminale :

https://www.youtube.com/watch?v=jazXBDsKS5E&t=0s

revoir la partie translation minutes 22

switch user symfony  --> google (pour se connecter a la place d'une autre personne)

https://symfony.com/doc/current/security/impersonating_user.html

pour notre projet il n'y a pas de différence entre symfony console et php bin/console

par contre si on travail avec  un projet docker vaut mieux utiliser symfony console (il prend en compte les variables d'environnements)

Securiser l'accès à https://127.0.0.1:8000/pins/create (accès autorisé

Une facon de récupérer l'utilisateur connecté en dhors du controller on fait ceci :

$user = $token->getUser();  comme dans la méthode getUser() dans AbstractController


pour recupérer le $user dans une extension par exemple ( on a pas accès a $token ni $this->getUser();)

on fait ceci :

symfony console security debug:autowiring security  et on tombe sur

Symfony\Component\Security\Core\Security (security.helper)

dans le constructeur :

use Symfony\Component\Security\Core\Security;

private $security;
public function  __consctruct (Security $security) {
   $this->security = $security;
}

dans une methode :

$user = $security->getUser();

dans la classe Security.php on a une méthode getUser() --> permet de récupérer l'utilisateur

le composant string est très intéressant a utiliser pour les chaines de caractères :

https://symfony.com/doc/current/components/string.html

symfony console debug:autowiring slug    et on tombe sur ceci :

 Creates a URL-friendly slug from a given string.
 Symfony\Component\String\Slugger\SluggerInterface (slugger)

----------------inscription------------------

Faire la partie inscription de user :

Crée un nouveau système de formulaire d'inscription :

symfony console make:registration-form     Creates a new registration form system

reponse au question

y
y

on ne demande d'installer : composer require symfonycasts/verify-email-bundle

pour l'adresse a utiliser pour l'émail d'envoie on utilise : noreplay@nadir.com

pour cette question :
 Would you like to include the user id in the verification link to allow anonymous email verification? (yes/no) [no]:
 >
réponder par no


What "name" should be associated with that email address? e.g. "Acme Mail Bot":
 > Panterest

 Do you want to automatically authenticate the user after registration? (yes/no) [yes]:
 > yes

répondez par oui :

etapes suivante :

 Next:
 1) Install some missing packages:
      composer require symfonycasts/verify-email-bundle
 2) In RegistrationController::verifyUserEmail():
    * Customize the last redirectToRoute() after a successful email verification.
    * Make sure you're rendering success flash messages or change the $this->addFlash() line.
 3) Review and customize the form, controller, and templates as needed.
 4) Run "php bin/console make:migration" to generate a migration for the newly added User::isVerified property.

 Then open your browser, go to "/register" and enjoy your new form!

minute 59 pour erreur envoie de mail variable

il y a une érreur qui apparait concerne le champs : is_verified
il faut jouer une migration pour prendre le champs en compte

important pour récupérer un champs du formulaire qui n'appartient pas à l'entité User en fait ceci :

$form->get('plainPassword')->getData();   --> pour récupérer le mot de passe ou bien
$form['plainPassword']->getData();

pour ajouter dans le formulaire un champs qui n'existe pas dans d'entité alors on rajoute 'mapped' => 'false'

La configuration d'envoie de mail en local est différente de celle a utiliser en production

mailtrap a utiliser uniquement en développement


au lieu de faire dans RegisterController :
             $entityManager = $this->getDoctrine()->getManager();
en fait ceci
              injecter le service  : EntityManagerInterface dans la méthode register


pour tester l'envoie de mail en local (sans internet)  en utilise par exemple maildev (ou mailcatcher)

doc pour l'installation :
https://maildev.github.io/maildev/


Utiliser messenger component pour envoyer des messages en liste d'attentes, regarder la video de honoré sur youtube

principe : en attend pas a ce que le mail envoyé pour confirmé a l'utilisateur son inscription car ca peut etre long

donc on confirme à l'utilisateur que son inscription est bonne puis en lui envoie le mail en arrière plan.

https://symfony.com/doc/current/components/messenger.html

Si on est connecté on affiche pas le formualire d'inscription


Gérer la partie validation de données


 Pour empecher qu'une adreese email soit utiliser deux fois on a cette validation dans l'entité user:

 * @UniqueEntity(fields={"email"}, message="There is already an account with this email")

 ici nous avons utiliser l'email comme un champs unique mais on peut bien utiliser d'autres attributs comme firstname, ...

 remarque on peut aussi empecher qu'il aurrait une combinaison cad : pas de user avec le meme nom et prénom :

  * @UniqueEntity(fields={"firstname" , "lastname"}, message="adapter ton message")


  pour vérifier que l'email est unique et aussi que le firstname est unique alors on va ajouter deux fois @UniqueEntity on sépare les champs email et entite

    @UniqueEntity(fields={"email"}, message="adapter ton message")
    @UniqueEntity(fields={"firstname"}, message="adapter ton message")

     quand on a un seul champs dans fields alors on peut enlever les accolades comme ceci :

     @UniqueEntity(fields="email",

--------------------------------------------------------------- Video 9 -------------------------------------------------------------------------------------

améliorer la sécurité de notre application :

pour le moment le logout c'est juste un lien / une requete GET : il faut éviter de faire des requete GET sur opérations qui vont modifier le state de notre application

Avec un lien GET on est vulnérable au fail CSRF

remarque on peut rajouter la protection csrf même-ci on avait la requete GET

Pour le lien de déconnexion on change d'état ( de déconnexion a la connexion ) donc vaut mieux utiliser une autre méthode plutot que GET

On va utiliser la méthode post avec la protection CSRF et on verra après GET avec CSRF


Pour voir la configuration du bundle security on fait ceci :

symfony console config:dump security

pour la configuration quand on voit (tild) ~ vaut dire que c'est null

pour voir ce qu'on peut utiliser avec le token on tape :

symfony console debug:autowiring token  et on tombe sur :

 Manages CSRF tokens.
 Symfony\Component\Security\Csrf\CsrfTokenManagerInterface (security.csrf.token_manager)

on a une autre solution avec GET à la minute 32;

Encore plus simple : en utilise ceci :


                    <li class="nav-item">
                        <a class="nav-link" href="{{ logout_path('main') }}">Logout</a>
                    </li>

                    main : c'est le nom du firewall dans security.yaml

                    une autre solution :

                     <li class="nav-item">
                        <a class="nav-link" href="{{ logout_url('main') }}">Logout</a>
                    </li>


        Nous nous utilisons la méthode POST



Ajouter un lien au niveau de la page d'accueil pour supprimer un Pin :

problème : chaque a un formulaire et tout les formulaire ont le même id donc : on ne supprime pas le bon élément

Voila le code a utiliser au cas ou on supprime sur la page index :

           <a href="#"
                               onclick="event.preventDefault();confirm('Are you confirm ?') && document.getElementById('js-delete-form-{{ pin.id }}').submit();"
                               class="ml-3 mb-3 btn btn-danger">&times; Delete</a>
                            <form id="js-delete-form-{{ pin.id }}" action="{{ path('app_pins_delete', {id:pin.id}) }}" method="post"
                                  style="display: none">
                                <input type="hidden" name="crsf_token" value="{{ csrf_token('pin_deletion_' ~ pin.id) }}">
                                <input type="hidden" name="_method" value="DELETE">
                            </form>




Au lieu d'ajouter les a Pin un a un alors il est préférable d'avoir une commande qu'on va lancer et elle nous crée les données dont on a besoin (Fixture)

https://symfony.com/doc/current/bundles/DoctrineFixturesBundle/index.html

dans notre exemple on utilise  mockaroo.com (il nous permet de générer de fausses données,
on aurra un code sql a éxécuter et ca va marcher, c'est simple a utiliser par rapport aux autres

Regarder la formation devenir pro symfony pour apprendre mieux sur les fixtures

Pour voir le code source en ligne (Github) :

https://github.com/mercuryseries/panterest

error404 path : Fix layout path for the 404 error template

pour eviter d'ecrire/répéter a plusieurs endroit :
           les variables : 'noreplay@nadir.com', 'Panterest' comme dans
                ->from(new Address('noreplay@nadir.com', 'Panterest'))  //RegistrationController
                alors on va définir des variables d'environnement dans le fichier .env

dans le fichier .env
MAIL_FROM_ADRESS=hello@panterest.com
MAIL_FROM_NAME="Panterest bot"

comment acceder dans un Controller au variable de .env :

google : recherche symfony dotenv :

https://symfony.com/doc/4.1/components/dotenv.html

Access the value with getenv() in your code:
$dbUser = getenv('MAIL_FROM_ADRESS');
 ou bien :
$_ENV['MAIL_FROM_ADRESS']


Imporant : si on a des variables qui ne change pas d'un environnement
à un autre alors au lieu d'utiliser .env en utilise les paramètres du container

aller dans config/service.yaml

parameters:
    app.mail_from_name:
    app.mail_from_address:

    puis pour récupérer les variables dans le code :

    $this->getParameter('app.mail_from_address')


on préfixe les variable avec app. pour ne pas les confondre avec les variables des bundles ou du système

on utilise les vaiables d'env (.env )si on a des variables qui changes d'un environnement à un autre

si on a des variables qui ne change pas d'un env a un autre  alors on utilise les paramètres du container service.yaml


si on veut par exemple utiliser une constante dans le controller PinsController alors en fait ceci :

dans l'entité pin:

public const NUM_ITEMS_PER_PAGE = 20 ; // nombre items par page, pour la pagination par exemple

Dans le controller en fait  Pin::NUM_ITEMS_PER_PAGE; beaucoup mieux que d'ecrire un chiffre en dur dans le controller

dans service.yaml en peut récupérer des variables dans .env comme dans mailer.yaml
example dans mailer.yaml
framework:
    mailer:
        dsn: '%env(MAILER_DSN)%'


Les bonnes pratiques de Symfony :

dans google :
symfony best practices

https://symfony.com/doc/current/best_practices.html

dans notre système actuell nous avons pour confirmer l'inscription alors il faut etre connecté

si on est pas connecté cette ligne va ne rediriger vers la page de login :
        $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY');


challenge : si l'utilisateur n'a recu de mail de confirmation donner lui la possibilité de renvoyer un nouveau lien de vérification

et avant de créer un pin l'utilisateur doit confirmer son email

comment faire : extraire la partie envoie de mail  (EmailVerifier) mis la dans une class dédié

commit : "remove unecessary parenthesis"  : supprimer les parenthèses inutile


------------------------------------------------------- Video 10 (Réinitialisation de mot de passe)----------------------------------------------
il y a une commande qui permet de générer le code nécessaire

1. tapez : symfony console
2.   make:reset-password Create controller, entity, and repositories for use with symfonycasts/reset-password-bundle
3.   symfony console  make:reset-password
4.   composer require symfonycasts/reset-password-bundle
5.   symfony console make:reset-password

répodez
1. entrer
2. hello@parlonscode.com
3. name :  Panterest


suivant :
Next:
   1) Run "php bin/console make:migration" to generate a migration for the new "App\Entity\ResetPasswordRequest" entity.
   2) Review forms in "src/Form" to customize validation and labels.
   3) Review and customize the templates in `templates/reset_password`.
   4) Make sure your MAILER_DSN env var has the correct settings.
   5) Create a "forgot your password link" to the app_forgot_password_request route on your login form.

 Then open your browser, go to "/reset-password" and enjoy!


 avant de jouer la migration, ajouter dans l'entité :

 ResetPasswordRequest

  * @ORM\Table(name="reset_password_requests")
puis :
php bin/console make:migration

    public function getDescription(): string
    {
        return 'Create reset_password_requests table';
    }

php bin/console doctrine:migrations:migrate

quand on réinistialise le mot de passe en réponds avec le même message que ce soit on a trouvé
l'email ou pas, on donne toujours le minimum d'info

Note formulaire : si on a un formualire qui est asscocié  a une entité alors le contraintes sont dans l'entité sinon dans le FormType

on peut faire ceci :


   $user = $this->getDoctrine()->getRepository(User::class)->findOneBy([
            'email' => $emailFormData,
        ]);

        mais aussi


   $user = $this->getDoctrine()->getRepository(User::class)->findOneByEmail($emailFormData);
   $user = $this->getDoctrine()->getRepository(User::class)->findOneByUsername($username);
   etc .......


--------------------Gérer le profil de l'utilisateur --------------------
modifier ces infos personnels
changer son mot de passe

créer un controller AccountController

symfony console make:controller account    (symfony rajoutera le suffix)

pour gérer l'avatar

http://fr.gravatar.com/

-----------------------------page edition de compte----------------------------

créer un formulaire pour éditer le profil

symfony console make:form UserForm

le forulaire est associé à l'entité User

-------------------------------------------changer de mot de passe--------------------------------------

le formulaire de changement de mot de passe ressemble a celui de reset

en utlise le formulaire de reset password

une fois que ca marche, en ajoute le mot de passe courant

----------------------------ajouter un champ : mot de passe courant---------------------

on vérifie si le mot de passe courant est bon sinon en change rien

on passeune option :  ['current_password_is_required'=> true] lors de la creation du formulaire pour afficher le champs currentPassword

        $form = $this->createForm(ChangePasswordFormType::class,null, ['current_password_is_required'=> true]);

important : en peut passer des paramètres au formulaire (FormType) depuis la méthod  createForm($option)


----------------------------------- (video11) Épisode 11/11 Autorisation - Gestion des droits d'accès -------------------------------------------------

En crée un pin uniquement si on a confirmé (activer notre compte)

pour éditer un pin il faut etre le createur du pin


On touche a la notion d'évenement EventSubscriber  : ajoute un message une fois que on est déconnnecté


Ajouter un message a la deconnexion :

a la deconnexion symfony va emmetre un evenement ayant pour nom logoutEvent qui sera dispatché

En peut faire pareil avec EventListener (par rapport a event dispatcher), voir la doc

En va créer un EventSubscriber qui va s'inscrire a un évenement


1. symfony console make:subscriber LogoutEventSubscriber
2. en ne demande a quelle evenment on va suscrire (beaucoup d'evenement existe):

nous en va choisir :

* Symfony\Component\Security\Http\Event\LogoutEvent (Symfony\Component\Security\Http\Event\LogoutEvent)

3. tapez dans le terminale :
Symfony\Component\Security\Http\Event\LogoutEvent

  What event do you want to subscribe to?:
 > Symfony\Component\Security\Http\Event\LogoutEvent


l'eventSubscriber ( LogoutEventSubscriber ) doit obligatoirement implémenter l'interface EventSubscriberInterface ( si comme ca que symfony va reconnaitre l'event )


pour générer une url dans l'evenet :

symfony console debug:autowiring url :

 UrlGeneratorInterface is the interface that all URL generator classes must implement.
 Symfony\Component\Routing\Generator\UrlGeneratorInterface (router.default)

important :           -----------première solution--------------

class LogoutEventSubscriber implements EventSubscriberInterface
{

    private $urlGenerator;
    public function __construct(UrlGeneratorInterface $urlGenerator)
    {
        $this->urlGenerator = $urlGenerator;
    }

    public function onLogoutEvent(LogoutEvent $event)
    {
        $event->getRequest()->getSession()->getFlashBag()->add(
            'success',
            'Logged out successfully!'
        );

        $event->setResponse(new RedirectResponse($this->urlGenerator->generate('app_home')));
    }

    public static function getSubscribedEvents()
    {
        return [
            LogoutEvent::class => 'onLogoutEvent',
        ];
    }
}

important :           -----------soconde solution--------------


en peut faire aussi:

symfony console debug:autowiring flash

The following classes & interfaces can be used as type-hints when autowiring:
 (only showing classes/interfaces matching flash)

 FlashBagInterface.
 Symfony\Component\HttpFoundation\Session\Flash\FlashBagInterface (session.flash_bag)

and

symfony console debug:autowiring router

 RouterInterface is the interface that all Router classes must implement.
 Symfony\Component\Routing\RouterInterface (router.default)


en peut uriliser RouterInterface a la place de UrlGeneratorInterface  car le premier hérite du deuxième

class LogoutEventSubscriber implements EventSubscriberInterface
{

    private $urlGenerator;
    private $flashBag;


    public function __construct(FlashBagInterface $flashBag,UrlGeneratorInterface $urlGenerator)
    {
        $this->urlGenerator = $urlGenerator;
        $this->flashBag = $flashBag;
    }

    public function onLogoutEvent(LogoutEvent $event)
    {
        $this->flashBag->add(
            'success',
            'Logged out successfully!'
        );

        $event->setResponse(new RedirectResponse($this->urlGenerator->generate('app_home')));
    }

    public static function getSubscribedEvents()
    {
        return [
            LogoutEvent::class => 'onLogoutEvent',
        ];
    }
}

petit rappel : en peut acceder a notre utilisateur via le token  : comme dans LoginFormAuthentificatorAuthenticator

comment faire :depuis notre évenement en peut acceder a note token puis vers le user :

$event->getToken()->getUser();

en peut aussi injecter Securiry $security dans le constructeur puis :

$this->security->getUser();

-------------------------------------------------partie autorisation-------------------------------------------
en va voir comment gérer les autorisation en symfony

en utilise l'attibut $roles dans l'entité User

pour voir a quoi correspond une page d'érreur en prod en fait ceci:

https://127.0.0.1:8000/_error/403


tapez dans google access_control symfony : pour des chose avancer

https://symfony.com/doc/current/security/access_control.html


en peut utiliser l'annotation isGranted pour les controles d'accès


si on veut faire un contole d'accès au niveau de twig alors en fait ceci :

pour afficher ou cacher un block selon le type(role) de d'utilisateur (ADMIN, USER...)

{% if (is_granted('ROLE_ADMIN') %}
  <p>Cool</p>
{% endif %}

Dans cette application (pinterest) en on n'a pas de role ADMIN (uniquement user)

si on veut faire controler l'accès au controlleur AccountController :

dans sécurity.yaml en fait ceci :

    access_control:
         - { path: ^/admin, roles: ROLE_USER }    --> uniquement les utilisateurs connecté peuvent acceder

  si on essair d'acceder par exemple à la page :

https://127.0.0.1:8000/account/change-password

alors on sera redirigé vers la page login grace a la méthode start

(start permet de dire qu'est ce qui va se passer si l'utilisateur tente d'accreder a une page sécurisé alors qu'il n'ai pas connecté))

start est dans LoginFormAuthentificatorAuthenticator (dans la class mère) qui hérite de AbstractFormLoginAuthenticator


      une autre anotation equivalente a isGranted

     * @Security("is_granted('ROLE_USER') && user.isVerified()") : permet de vérifier que l'utilisateur est connecté ainsi que son compte et verifié


     * @Security("is_granted('ROLE_USER') && user.isVerified() && pin.getUser() == user")



Note importante : a chaque fois qu'en utilise isGranted symfony fait appelle au Voter


Créer un Voter :

1. Symfony console make:voter
2. Donner le nom : PinVoter

pour les droit de EDIT et DELETE sont géné avec le PinVoter alors que CREATE est Gerer avec l'annotation : @Security("is_granted('ROLE_USER') && user.isVerified()")

Utiliser les voter pour la gestion des droit, c'est facile a faire


        $this->denyAccessUnlessGranted('PIN_EDIT', $pin); est equivalent à
             * @IsGranted("PIN_EDIT",subject="pin")








